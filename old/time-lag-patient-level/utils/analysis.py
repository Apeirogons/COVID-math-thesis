import pandas as pd 
import numpy as np
from itertools import combinations
import matplotlib.pyplot as plt
from statsmodels.graphics.gofplots import qqplot
from scipy.stats import normaltest, describe, iqr, linregress, gamma, weibull_min, lognorm
from scipy.optimize import curve_fit
import random
import os

def lag_function(x, a, h, c, k):
    return a/((x-h)/k) + c

def read_data(directory = 'differenced_data'):
    """
    Reads data generated by generate_starting_files.py
    Args:
        categories_of_interest: names of difference categories (list[tuple(str, str)])
        directory: location of the data generated by generate_starting_files.py (str)
    Returns:
        pd.DataFrame
    """
    differenced_data = {}
    for i, category in enumerate(os.listdir(directory)):
        category_data = {}
        for country_file in os.listdir(directory + '/' +category):
            category_data[country_file.split('.')[0]] = pd.read_csv(directory + '/'+ category + '/' +country_file)
        category_name = category.split('.')[0]
        category_tuple = (category_name.split('-')[0],  category_name.split('-')[1])
        differenced_data[category_tuple] = category_data
    return differenced_data
    
    
def summarize(diff, targets, save_values = False, show=True):
    """
    Computes summary statistics for the time differences and creates plots.
    Args:
        diff: time differences (pd.DataFrame)
        targets: names of difference categories in reverse chronological order, e.x. ('confirmation', 'admission') (tuple(str, str))
        save_values: whether or not to save values and plots to (path)/summary.txt
        show: whether or not to show plot (you will have to manually close each plot)
    Returns:
        summary_df: dataframe with target names, median, IQR, and number of observations (pd.DataFrame)
    """
    summary = describe(diff)
    g = gamma.fit(diff)
    L = lognorm.fit(diff)
    summary_string = []
    summary_string.append('Time between %s and %s in days.' % (targets[0], targets[1]))

    summary_string.append("Median: " + str(np.median(diff)))
    summary_string.append("IQR: " + str(iqr(diff)))
    summary_string.append('Number of samples: ' + str(summary.nobs))
    summary_string.append('Range: ' + str(summary.minmax))
    summary_string.append('Mean: ' + str(summary.mean))
    summary_string.append('Variance: ' + str(summary.variance))
    summary_string.append('Skewness: ' + str(summary.skewness))
    summary_string.append('Kurtosis: '+ str(summary.kurtosis))
    summary_string.append('Gamma distribution values: ' + str(g))
    summary_string.append('Lognormal distribution values: ' + str(L))
    summary_df = pd.DataFrame()
    summary_df['target_0'] = [targets[0]]
    summary_df['target_1'] = [targets[1]]
    summary_df['median'] = [np.median(diff)]
    summary_df['iqr'] = [iqr(diff)]
    summary_df['N'] = [summary.nobs]

    for ln in summary_string:
        print(ln)

    if save_values != False:
        new_dir = targets[0] + '-' + targets[1]

        if not os.path.exists(save_values):
            os.mkdir(save_values)

        if not os.path.exists(save_values+'/'+ new_dir):
            os.mkdir(save_values+'/'+new_dir)

        with open(save_values+'/'+ new_dir + '/summary.txt', 'w') as s:
            s.write('\n'.join(summary_string))
    
    plt.clf()
    fig, ax = plt.subplots()
    ax.set_title('Days between '+targets[0] + ' and '+targets[1])
    ax.set_xlabel('Days ')
    ax.set_ylabel('Probability density')
    n, bins, _ = ax.hist(diff, bins=10, density=True)

    ax.plot(np.linspace(1.5, bins[-1], 100), gamma.pdf(np.linspace(1.5, bins[-1], 100), g[0], g[1], g[2]), color='yellow', label='gamma')

    ax.plot(np.linspace(1.5, bins[-1], 100), lognorm.pdf(np.linspace(1.5, bins[-1], 100), L[0], L[1], L[2]), color='red', label = 'log-normal')
    ax.legend(loc='best', frameon=False)  
  #  W = weibull_min.fit(diff)
  #  ax.plot(np.linspace(1.5, bins[-1], 100), lognorm.pdf(np.linspace(1.5, bins[-1], 100), W[0], W[1], W[2]), color='yellow')

    if save_values:
        plt.savefig(save_values+'/'+new_dir + '/histogram.png', format='png')
    if show:
        plt.show()
    plt.close()

    plt.clf()
    fig, ax = plt.subplots()
    ax.set_title('Days between '+targets[0] + ' and '+targets[1])
    ax.set_ylabel('Days ')
    ax.boxplot(diff)
    if save_values:
        plt.savefig(save_values+'/'+new_dir + '/boxplot.png', format='png')
    if show:
        plt.show()
    plt.close()

    print(summary_df)
    return summary_df

def generate_qqplot(diff, targets, save_values = False, show=True): 
    """
    Generates and saves QQ-plots.
    Args:
        diff: time differences (list of numeric)
        targets: names of difference categories in reverse chronological order, e.x. ('confirmation', 'admission') (tuple(str, str))
        save_values: whether or not to save values and plots to (path)/summary.txt
        show: whether or not to show plot (you will have to manually close each plot)
    """  
    new_dir =  targets[0] + '-' + targets[1]
    print('Time between %s and %s in days.' % (targets[0], targets[1]))
    
    plt.clf()

    qqplot(diff, line='s')
    if show:
        plt.show()
    if save_values != False:
        if not os.path.exists(save_values+'/'+ new_dir):
            os.mkdir(save_values+'/'+new_dir)
        plt.savefig(save_values+'/'+ new_dir+'/qqplot.png', format='png')
    plt.close()

def trend(diff, mean_dates, targets, save_values = False, show=True):
    """
    Determines whether or not there is a time-varying trend in the time differences, based on the linear regression
    Args:
        diff: time differences (pd.DataFrame)
        mean_dates: days since Dec 1, 2019 for each difference in diff (pd.DataFrame)
        targets: names of difference categories in reverse chronological order, e.x. ('confirmation', 'admission') (tuple(str, str))
        save_values: whether or not to save values and plots to (path)/summary.txt
        show: whether or not to show plot (you will have to manually close each plot)
    Returns:
        summary_df: contains targets, slope values, and p-value on slope. (pd.DataFrame)
    """
    lr = linregress(mean_dates, diff) 
    trend_string = []
    trend_string.append('Days since Dec 1, 2019 vs Time between %s and %s in days.' % (targets[0], targets[1]))
    trend_string.append('Slope Point Estimate: ' + str(lr.slope))
    trend_string.append('Slope 95% CI: (' + str(round(lr.slope- lr.stderr*1.96,2)) + ', ' + str(round(lr.slope+ lr.stderr*1.96,2))+ ')')
    trend_string.append('Intercept Point Estimate: ' + str(lr.intercept))
    trend_string.append('p(slope == 0): ' + str(lr.pvalue))
    rn_dates=np.linspace(min(mean_dates), max(mean_dates), 100)

    summary_df = pd.DataFrame()
    summary_df['target_0'] = [targets[0]]
    summary_df['target_1'] = [targets[1]]
    summary_df['slope_point'] = [lr.slope]
    summary_df['slope_ci_min'] = [round(lr.slope- lr.stderr*1.96,2)]
    summary_df['slope_ci_max'] = [round(lr.slope+ lr.stderr*1.96,2)]
    summary_df['slope_intercept'] = [lr.intercept]
    summary_df['p'] = [lr.pvalue]
    for s in trend_string:
        print(s)
    
    if save_values:
        if not os.path.exists(save_values+'/'):
            os.mkdir(save_values+'/')

        new_dir = targets[0] + '-' + targets[1]
        if not os.path.exists(save_values+'/'+ new_dir):
            os.mkdir(save_values+'/'+new_dir)

        with open(save_values+'/'+ new_dir + '/regression.txt', 'w') as s:
            s.write('\n'.join(trend_string))

    plt.clf()
    fig, ax = plt.subplots()
    ax.set_title('Days between '+targets[0] + ' and '+targets[1])
    ax.set_ylabel('Time delay (days)')
    ax.set_xlabel('Days since Dec 1, 2019')
    ax.scatter(mean_dates, diff, alpha=0.5)



    ax.plot(rn_dates, lr[0]*rn_dates + lr[1], color='RED', label='y=mx+b')
    #try:
    #    a, h, c, k = curve_fit(lag_function, mean_dates, diff, p0=[-100, 30, 5, 0.001])[0]
    #    ax.plot(rn_dates, lag_function(rn_dates, a, h, c, k), color='YELLOW', label='y=a/((x-h)/k) + c')
    #except RuntimeError:
    #    pass
    ax.legend()
    if save_values:
        plt.savefig(save_values+'/' + new_dir+'/scatter.png', format='png')
    if show:
        plt.show()
    plt.close()

    return summary_df